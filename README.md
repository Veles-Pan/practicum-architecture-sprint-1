# Проект Mesto

## Требования

-   node 18+

## Запуск прод-сборки

```bash
docker compose up
```

## Установка зависимостей для разработки

### Frontend

```bash
cd frontend
npm i
```

### Backend

```bash
cd backend
npm i
```

## Локальный запуск

Так как во фронтенде используются микрофронтенды для его работы нужно поднять все проекты поочереди. Запуск нужно делать из директории `frontend`

```bash
cd frontend
npm run start
```

И открыть `http://localhost:3000`

# Задание 1

## Этап 1

Для управления микрофронтендами я выбрала фреймворк Module Federation, который позволяет легко настраивать и расширять микросервисы. Этот подход оптимизирует сборку и обновление сервисов

Для управления состояние я выбрала библиотеку глобального состояния и Redux, чтобы все части приложения использовали актуальное состояние. В этом проекте компоненты тесно связаны друг с другом и постоянно обращаются к общим данным, поэтому было принято решение использовать глобальное состояние

Также помимо самих микрофронтендов я вынесла переиспользуемые компоненты в отдельные пакеты в дериктории `packages`, чтобы эффективно переиспользовать код между сервисами (стор, конфиги, utils, небольшие компоненты)

## Этап 2

Всего я выделила 4 микрофронтенда:

-   Auth - регистрация и авторизация пользователей. Предоставляет:

    -   хук useCheckAuth для проверки токена в любой части приложения
    -   компонент Register с формой регистрации и полным флоу через Redux Async Thunk
    -   компонент Signin с формой для логина и полным флоу через Redux Async Thunk
    -   компонент SignOut с информацией о почте пользователя и возможность выйти из сессии

-   Profile

    -   компонент Profile с полной информацией о пользователе и возможностью сменить информацию/аватарку через Redux Async Thunk. Использует тот же user store, что и Auth сервис

-   Gallery

    -   компонент AddCard позволяет загрузить новую картинку через Redux Async Thunk (она появится на странице без обновления страницы)
    -   компонент Gallery представляет собой галлерею изображений. Тут происходит fetch-данных и предоставляются возможности поставить лайк (с оптимистичным апдейтом) или удалить изображение. Всё с помощью Redux Async Thunk

-   Host
    -   основное приложение, которое использует все сервисы. В приложении настроен роутинг, используются защищенные руты и основное управление всеми сервисами

Также в рамках проекта я реализовала общие пакеты в папке packages:

-   Build Config

    -   общие конфиги для вебпака, которые использует каждый сервис

-   Shared
    -   api классы для легкого доступа к апи авторизации и работы с галлереей
    -   data для глобального стора. Формально в Redux нельзя делать несколько изолированных сторов, но я постаралась сделать "имитацию" изолированных сторов отдельно для управления состояние пользователя и состояние галлереи
    -   routes для общей настройки маршрутизации и легкого изменения и добавления рутов в будущем
    -   components пока тут общие компоненты для попапов, но в будущем можно будет вынести и другие

## Этап 3

Можно легко открыть весь проект через докер, который запускает контейнеры в соответствии с конфигурацией, определенной в docker-compose.yml файле:

```bash
docker compose up
```

И открыть `http://localhost:3000`

Это будет продовая сборка. Для открытия приложения в dev-режиме можно воспользоваться следующими командами:

```bash
cd frontend
npm i
npm run start
```

И открыть `http://localhost:3000`

# Задание 2

Я выделила следующие микросервисы:

-   **User Service** — хранит всю информацию о пользователе и связан с аукционами, товарами/услугами, заявками и транзакциями через связь One-To-Many. Этот сервис используется сервисом авторизации и сервисом нотификаций для определения каналов связи пользователя. При любых взаимодействиях с аукционами и товарами/услугами всегда проверяются роль пользователя и его разрешения.

-   **Notifications Service** — простой сервис нотификаций, который получает call-to-action из других сервисов, проверяет настройки пользователя, ищет его актуальные каналы связи и отправляет уведомления. Отправка уведомлений организована через очередь (например, RabbitMQ), чтобы не блокировать запрос и обеспечить отказоустойчивость.

-   **Auth Service** — классический сервис авторизации/аутентификации, который проверяет и обновляет токены, валидирует пользователя.

-   **Payment Service** — сервис, который обрабатывает платежи.

-   **Orders Service** — сервис заказов. Пользователь создаёт товар или услугу и размещает его в открытый доступ (в виде заказа). Здесь содержится вся подробная информация о потребностях пользователя или о том, что пользователь может предоставить. У каждого заказа есть связь с userId владельца и ID аукциона (если товар предполагает аукцион).

-   **Auctions Service** — сервис аукционов. Хранит информацию о всех заявках, поданных пользователями, и связан с сервисом заказов через связь One-to-One по OrderID. По завершении аукциона сервис посылает запрос с ID пользователя-победителя в Payment Service, и только после успешного завершения транзакции считается завершённым.

-   **Support Service** — сервис для обращения в поддержку. Сотрудник поддержки имеет соответствующую роль и может просматривать или изменять любые необходимые данные, например, приостановить аукцион на время апелляции.

[Ссылка](https://viewer.diagrams.net/?tags=%7B%7D&lightbox=1&highlight=0000ff&edit=_blank&layers=1&nav=1&title=task2.drawio#Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D1DTL0DyT5Oti4y8vnufVNjYeTHXpCVND_%26export%3Ddownload)
